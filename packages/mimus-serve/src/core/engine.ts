import { FastifyReply } from "fastify";
import { IncomingMessage } from "node:http";

import { BodyPatternsMatcher } from "../matchers/body-patterns";
import { CookiesMatcher } from "../matchers/cookies";
import { HeadersMatcher } from "../matchers/headers";
import { MethodMatcher } from "../matchers/method";
import { QueryParametersMatcher } from "../matchers/query-params";
import { UrlMatcher } from "../matchers/url";
import { BaseResponseRenderer } from "../renderers/BaseResponseRenderer";
import { DatasetResponseRenderer } from "../renderers/DatasetResponseRenderer";
import { GroqResponseRenderer } from "../renderers/GroqResponseRenderer";
import { JsonataResponseRenderer } from "../renderers/JsonataResponseRenderer";
import { ProcessingResponseRenderer } from "../renderers/ProcessingResponseRenderer";
import { ProxyResponseRenderer } from "../renderers/ProxyResponseRenderer";
import {
  Configuration,
  Context,
  DEFAULT_HTTP_RESPONSE,
  HttpRequest,
  HttpResponse,
  Mapping,
  Method,
  NameValuePair,
  RequestMatcher,
  ResponseDefinition,
  ResponseRenderer,
  UrlMatchType,
} from "../types";
import { delay } from "../utils/promises";
import { buildRequestModel } from "../utils/request";
import { processTemplate } from "../utils/templating";
import { findMapping } from "./mapping";
import { Runtime } from "./runtime";

const DEFAULT_REQUEST_MATCHERS: RequestMatcher[] = [
  new UrlMatcher(),
  new MethodMatcher(),
  new QueryParametersMatcher(),
  new CookiesMatcher(),
  new HeadersMatcher(),
  new BodyPatternsMatcher(),
];

const DEFAULT_RESPONSE_RENDERERS: ResponseRenderer[] = [
  new BaseResponseRenderer(),
  new ProcessingResponseRenderer(),
  new DatasetResponseRenderer(),
  new ProxyResponseRenderer(),
  new JsonataResponseRenderer(),
  new GroqResponseRenderer(),
];

/**
 * Transforms an array of `NameValuePair` objects by processing their values as templates with the given `Context`.
 * If a value is an array, each element is processed as a template.
 * If a processed value is undefined, the corresponding `NameValuePair` is filtered out.
 *
 * @param headers - The array of `NameValuePair` objects to transform.
 * @param context - The `Context` to use for processing templates.
 * @returns An array of `NameValuePair` objects with processed values.
 */
export const transformHeaders = (
  headers: NameValuePair[],
  context: Context,
): NameValuePair[] => {
  return headers
    .map((header) => {
      const { name, value } = header;
      let newValue: string | string[] | undefined;

      if (Array.isArray(value)) {
        newValue = value.map((v) => processTemplate(v, context) as string);
      } else {
        newValue = processTemplate(value, context);
      }

      return { name, value: newValue };
    })
    .filter((header) => header.value !== undefined);
};

/**
 * Transforms a `ResponseDefinition` object by processing its properties as templates with the given `Context`.
 * The `statusMessage`, `body`, and `bodyFileName` properties are processed as templates.
 * The `headers` property is transformed using `transformHeaders`.
 *
 * @param responseDefinition - The `ResponseDefinition` object to transform.
 * @param context - The `Context` to use for processing templates.
 * @returns A transformed `ResponseDefinition` object.
 */
export const transformResponseDefinition = (
  responseDefinition: ResponseDefinition,
  context: Context,
): ResponseDefinition => {
  return {
    ...responseDefinition,
    statusMessage: processTemplate(responseDefinition.statusMessage, context),
    body: processTemplate(responseDefinition.body, context),
    headers: transformHeaders(responseDefinition.headers, context),
    bodyFileName: processTemplate(responseDefinition.bodyFileName, context),
  };
};

/**
 * Processes an incoming HTTP request and returns an HTTP response into the provided 'reply'.
 * The request is matched against the provided mappings and the first matching mapping is used to generate the response.
 * The response is generated by looping over the available response renderers and rendering the response.
 * The response is then transformed by processing its properties as templates with the given `Context`.
 * The `statusMessage`, `body`, and `bodyFileName` properties are processed as templates.
 * The `headers` property is transformed using `transformHeaders`.
 * The response is then returned via the specified reply.
 *
 * @param configuration - The server configuration.
 * @param mappings - The server mappings.
 * @param runtime - The server runtime.
 * @param incomingMessage - The incoming HTTP message.
 * @param incomingCookies - The incoming cookies.
 * @param reply - The Fastify reply object.
 * @param body - The request body.
 * @param isHttps - Whether the request is HTTPS or not.
 * @returns The HTTP response.
 */
export const processRequest = async (
  configuration: Configuration,
  mappings: Mapping[],
  runtime: Runtime,
  incomingMessage: IncomingMessage,
  incomingCookies: Record<string, string | undefined>,
  reply: FastifyReply,
  body: any,
  isHttps: boolean,
) => {
  const headers = Object.entries(incomingMessage.headers).map(
    ([name, value]) => ({
      name,
      value,
    }),
  );
  // map incoming cookies to NameValuePair[]
  const cookies = Object.entries(incomingCookies).map(([name, value]) => ({
    name,
    value,
  }));

  const mappedRequest: HttpRequest = {
    method: incomingMessage.method as Method,
    url: incomingMessage.url ?? "",
    headers,
    cookies,
    body: body,
  };
  const mapping = findMapping(
    DEFAULT_REQUEST_MATCHERS,
    mappings,
    runtime,
    mappedRequest,
  );

  if (mapping !== undefined) {
    const requestModel = buildRequestModel(
      incomingMessage,
      headers,
      body,
      incomingCookies,
      isHttps,
      mapping?.requestMatch.urlType === UrlMatchType.PathParams
        ? mapping?.requestMatch.url
        : undefined,
    );
    const context: Context = {
      request: requestModel,
    };
    const responseDefinition =
      mapping.responseDefinition.transform || configuration.general.transform
        ? transformResponseDefinition(mapping.responseDefinition, context)
        : mapping.responseDefinition;

    let response: HttpResponse = DEFAULT_HTTP_RESPONSE;
    //loop over all renderers and render the response
    try {
      for (const renderer of DEFAULT_RESPONSE_RENDERERS) {
        response = await renderer.render(
          configuration,
          mapping,
          runtime,
          responseDefinition,
          context,
          response,
        );
      }

      await delay(
        Math.max(
          responseDefinition.fixedDelayMilliseconds,
          configuration.general.fixedDelayMilliseconds,
        ),
      );

      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      reply.code(response.status);

      // if (response.statusMessage !== undefined) {
      //   serverResponse.statusMessage = response.statusMessage;
      // }

      response.headers.forEach((h) => reply.header(h.name, h.value ?? ""));

      if (response.body !== undefined) {
        await reply.send(response.body);
      }

      // Change scenario state if necessary
      if (
        mapping.scenarioName !== undefined &&
        mapping.newScenarioState !== undefined
      ) {
        runtime.changeScenarioState(
          mapping.scenarioName,
          mapping.newScenarioState,
        );
      }
    } catch (error: any) {
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      reply.code(500);
      console.error("Error while processing request", error.message);
      await reply.send("Error processing request: " + error.message);
    }
    // serverResponse.end();
  } else {
    // eslint-disable-next-line @typescript-eslint/no-floating-promises
    reply.code(500);
    await reply.send("No mapping found for this request");
    // serverResponse.end();
  }
};
